Регистр, представляющий переменную k.
		переменную k представляет регистр t0(x5)

Регистр, представляющий переменную sum.
		переменную sum представляет регистр s0

Регистры, действующие как указатели на массивы source и dest.
	данными регистрами являются s1 , s2

Ассемблерный код для цикла, найденного в коде C.
		loop:
		    slli s3, t0, 2		# будем постоянно умножать на 4, дабы итерироваться по массиву, где каждый элемент имеет размер 4
		    add t1, s1, s3		# получение ссылки на элемент масссива  source[k] ? т.е. *source[k]
		    lw t2, 0(t1)		# получение самого значения source[k].  t2 = source[k]
		    beq t2, x0, exit	# сравнение элемента с нулём по условию цикла
		    add a0, x0, t2		# передаём в аргумент функции элемент source[k]
		    addi sp, sp, -8		# резервируем на стеке место ещё под две переменные
		    sw t0, 0(sp)		# сохраняем две переменные на стек .   Хороший вопрос. Когда мы их сохранили в память, перед использованием в функции, мы должны их заксорить?
		    sw t2, 4(sp)
		    jal fun				# прыгаем на функции, притом параметр функции в регистре a0
		    lw t0, 0(sp)		# возвращаем наши старые переменные
		    lw t2, 4(sp)
		    addi sp, sp, 8		# освобождаем стекфреймы
		    add t2, x0, a0		# ??????????? Что лежит в a0? fun()??? dest[k] = fun(source[k]);
		    add t3, s2, s3      # делаем *dest[k]
		    sw t2, 0(t3)		# t2 = dest[k]
		    add s0, s0, t2		# sum += dest[k]
		    addi t0, t0, 1		# k+=
		    jal x0, loop		# идём на новую итерацию цикла.

Как указатели манипулируются в ассемблерном коде.
		при помощи конструкций x(register), где x -  смещение, а register - память, относительно которой смещаемся, туда мы можем передавать регистры, содержащие адреса памяти.
		то есть, сначала мы делаем la s1, source, загружая адрес source в s1 , затем мы итерируемся по адресу, прибавляя нужное смещение add t1, s1, s3 , и только потом получаем само число lw t2, 0(t1) 

	
